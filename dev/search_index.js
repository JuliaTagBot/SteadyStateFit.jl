var documenterSearchIndex = {"docs":
[{"location":"#SteadyStateFit.jl-1","page":"Home","title":"SteadyStateFit.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"SteadyStateFit.SteadyStateObjective\nSteadyStateFit.solve","category":"page"},{"location":"#SteadyStateFit.SteadyStateObjective","page":"Home","title":"SteadyStateFit.SteadyStateObjective","text":"SteadyStateObjective(\n    loss,\n    ode::ODEProblem,\n    conditions::AbstractVector,\n    conditionsetter::Lens,\n    parameterlens::Lens,\n    steadystatesolver = NLSolver(),\n)\n\nSteadyStateObjective defines an objective function that x â†¦ F(x) that computes\n\nloss(states :: AbstractVector{TU}, conditions :: AbstractVector{TC}, sso) :: Real\n\nwhere\n\nstates is a vector of steady state u(x, c :: TC) :: TU of the ode computed given a trainable parameter x and each c in conditions,\nconditions is the argument passed to SteadyStateObjective, and\nsso is a SteadyStateObjective such that sso.p contains the parameter x for which the objective is evaluated; i.e. sso.p is set(ode.p, parameterlens, x).\n\nThe trainable parameter x and the \"external\" condition c are set using parameterlens and conditionsetter lenses which act on ode.p respectively.\n\nSteadyStateObjective also provides Jacobian in the fg!(F, G, x) form required by Optim.only_fg!.\n\n\n\n\n\n","category":"type"},{"location":"#DiffEqBase.solve","page":"Home","title":"DiffEqBase.solve","text":"solve(sso::SteadyStateObjective, [method, options, x0]) :: SteadyStateFitResult\n\nOptimize a SteadyStateObjective sso using Optim.  The rest of the positional and keyword arguments are passed to Optim.optimize.\n\n\n\n\n\n","category":"function"}]
}
